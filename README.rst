.. image:: https://travis-ci.org/binji/sexpr-wasm.svg?branch=master
    :target: https://travis-ci.org/binji/sexpr-wasm
    :alt: Build Status

sexpr-wasm
==========

Translates from WebAssembly `s-expressions
<https://github.com/WebAssembly/spec>`_ to `v8-native-prototype
<https://github.com/WebAssembly/v8-native-prototype>`_ bytecode.

Cloning
-------

Clone as normal, but don't forget to update/init submodules as well::

  $ git clone https://github.com/binji/sexpr-wasm
  $ git submodule update --init

This will fetch the v8-native-prototype repo, which is needed for some tests.

Building
--------

Building just sexpr-wasm::

  $ make
  mkdir out
  cc -Wall -Werror -g -c -o out/sexpr-wasm.o src/sexpr-wasm.c
  cc -Wall -Werror -g -c -o out/wasm-parse.o src/wasm-parse.c
  cc -Wall -Werror -g -c -o out/wasm-gen.o src/wasm-gen.c
  cc -o out/sexpr-wasm out/sexpr-wasm.o out/wasm-parse.o out/wasm-gen.o

If you make changes to src/hash.txt, you'll need to install gperf as well. On
Debian-based systems::

  $ sudo apt-get install gperf
  ...
  $ touch src/hash.txt
  $ make
  gperf --compare-strncmp --readonly-tables --struct-type src/hash.txt --output-file src/hash.h
  ...

Building v8-native-prototype
----------------------------

The v8-native-prototype lets you run the generated bytecode. Some of the tests
rely on this repo. To build it::

  $ scripts/build-d8.sh
  ...

When it is finished, there will be a d8 executable in the
``third_party/v8-native-prototype/v8/v8/out/Release`` directory.

Running
-------

First write some WebAssembly s-expressions::

  $ cat > test.wasm << HERE
  (module
    (export "test" 0)
    (func (result i32)
      (i32.add (i32.const 1) (i32.const 2))))
  HERE

Then run sexpr-wasm to build v8-native-prototype bytecode::

  $ out/sexpr-wasm test.wasm -o test.bin

This can be loaded into d8 using JavaScript like this::

  $ third_party/v8-native-prototype/v8/v8/out/Release/d8
  V8 version 4.7.0 (candidate)
  d8> buffer = readbuffer('test.bin');
  [object ArrayBuffer]
  d8> module = WASM.instantiateModule(buffer, {});
  {memory: [object ArrayBuffer], test: function test() { [native code] }}
  d8> module.test()
  3

If you just want to run a quick test, you can use the run-d8.py script instead::

  $ test/run-d8.py test.wasm
  test() = 3

Tests
-----

To run tests::

  $ make test
  [+251|-0|%100] (0.55s)

In this case, there were 251 passed tests and no failed tests, which took .55
seconds to run.

You can also run the Python test runner script directly::

  $ test/run-tests.py
  [+251|-0|%100] (0.40s)

  $ test/run-tests.py -v
  + bad-string-escape.txt (0.002s)
  + bad-string-hex-escape.txt (0.004s)
  + bad-string-eof.txt (0.005s)
  + bad-toplevel.txt (0.003s)
  ...

To run a subset of the tests, use a glob-like syntax::

  $ test/run-tests.py const -v
  + dump/const.txt (0.003s)
  + expr/bad-const-i32-garbage.txt (0.002s)
  + expr/bad-const-f32-trailing.txt (0.004s)
  + expr/bad-const-i32-overflow.txt (0.003s)
  + expr/bad-const-i32-trailing.txt (0.002s)
  + expr/bad-const-i32-just-negative-sign.txt (0.003s)
  + expr/const.txt (0.003s)
  + expr/bad-const-i32-underflow.txt (0.004s)
  + expr/bad-const-i64-overflow.txt (0.005s)
  [+9|-0|%100] (0.02s)

  $ test/run-tests.py expr*const*i32 -v
  + expr/bad-const-i32-garbage.txt (0.004s)
  + expr/bad-const-i32-overflow.txt (0.002s)
  + expr/bad-const-i32-trailing.txt (0.002s)
  + expr/bad-const-i32-just-negative-sign.txt (0.002s)
  + expr/bad-const-i32-underflow.txt (0.002s)
  [+5|-0|%100] (0.01s)
